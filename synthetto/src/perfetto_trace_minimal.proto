/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto2";

package perfetto.protos;

// Begin of protos/perfetto/trace/track_event/counter_descriptor.proto

// Defines properties of a counter track, e.g. for built-in counters (thread
// time, instruction count, ..) or user-specified counters (e.g. memory usage of
// a specific app component).
//
// Counter tracks only support TYPE_COUNTER track events, which specify new
// values for the counter. For counters that require per-slice values, counter
// values can instead be provided in a more efficient encoding via TrackEvent's
// |extra_counter_track_uuids| and |extra_counter_values| fields. However,
// slice-type events cannot be emitted onto a counter track.
//
// Values for counters that are only emitted on a single packet sequence can
// optionally be delta-encoded, see |is_incremental|.
//
// Next id: 7.
message CounterDescriptor {

  // // Built-in counters, usually with special meaning in the client library,
  // // trace processor, legacy JSON format, or UI. Trace processor will infer a
  // // track name from the enum value if none is provided in TrackDescriptor.
  // enum BuiltinCounterType {
  //   COUNTER_UNSPECIFIED = 0;
  //
  //   // Thread-scoped counters. The thread's track should be specified via
  //   // |parent_uuid| in the TrackDescriptor for such a counter.
  //
  //   // implies UNIT_TIME_NS.
  //   COUNTER_THREAD_TIME_NS = 1;
  //
  //   // implies UNIT_COUNT.
  //   COUNTER_THREAD_INSTRUCTION_COUNT = 2;
  // }

  // Type of the values for the counters - to supply lower granularity units,
  // see also |unit_multiplier|.
  enum Unit {
    UNIT_UNSPECIFIED = 0;
    UNIT_TIME_NS = 1;
    UNIT_COUNT = 2;
    UNIT_SIZE_BYTES = 3;
    // TODO(eseckler): Support more units as necessary.
  }

  // // For built-in counters (e.g. thread time). Custom user-specified counters
  // // (e.g. those emitted by TRACE_COUNTER macros of the client library)
  // // shouldn't set this, and instead provide a counter name via TrackDescriptor.
  // optional BuiltinCounterType type = 1;

  // Names of categories of the counter (usually for user-specified counters).
  // In the client library, categories are a way to turn groups of individual
  // counters (or events) on or off.
  repeated string categories = 2;

  // Type of the counter's values. Built-in counters imply a value for this
  // field.
  optional Unit unit = 3;

  // In order to use a unit not defined as a part of |Unit|, a free-form unit
  // name can be used instead.
  optional string unit_name = 6;

  // Multiplication factor of this counter's values, e.g. to supply
  // COUNTER_THREAD_TIME_NS timestamps in microseconds instead.
  optional int64 unit_multiplier = 4;

  // Whether values for this counter are provided as delta values. Only
  // supported for counters that are emitted on a single packet-sequence (e.g.
  // thread time). Counter values in subsequent packets on the current packet
  // sequence will be interpreted as delta values from the sequence's most
  // recent value for the counter. When incremental state is cleared, the
  // counter value is considered to be reset to 0. Thus, the first value after
  // incremental state is cleared is effectively an absolute value.
  optional bool is_incremental = 5;

  // When visualizing multiple counter tracks, it is often useful to have them
  // share the same Y-axis range. This allows for easy comparison of their
  // values.
  //
  // All counter tracks with the same |y_axis_share_key| and the same parent
  // track (e.g. grouped under the same process track) will share their y-axis
  // range in the UI.
  optional string y_axis_share_key = 7;
}

// Begin of protos/perfetto/trace/track_event/thread_descriptor.proto

// Describes a thread's attributes. Emitted as part of a TrackDescriptor,
// usually by the thread's trace writer.
//
// Next id: 9.
message ThreadDescriptor {
  optional int32 pid = 1;
  optional int32 tid = 2;

  optional string thread_name = 5;

  // // ---------------------------------------------------------------------------
  // // Deprecated / legacy fields, which will be removed in the future:
  // // ---------------------------------------------------------------------------
  //
  // enum ChromeThreadType {
  //   CHROME_THREAD_UNSPECIFIED = 0;
  //
  //   CHROME_THREAD_MAIN = 1;
  //   CHROME_THREAD_IO = 2;
  //
  //   // Scheduler:
  //   CHROME_THREAD_POOL_BG_WORKER = 3;
  //   CHROME_THREAD_POOL_FG_WORKER = 4;
  //   CHROME_THREAD_POOL_FB_BLOCKING = 5;
  //   CHROME_THREAD_POOL_BG_BLOCKING = 6;
  //   CHROME_THREAD_POOL_SERVICE = 7;
  //
  //   // Compositor:
  //   CHROME_THREAD_COMPOSITOR = 8;
  //   CHROME_THREAD_VIZ_COMPOSITOR = 9;
  //   CHROME_THREAD_COMPOSITOR_WORKER = 10;
  //
  //   // Renderer:
  //   CHROME_THREAD_SERVICE_WORKER = 11;
  //
  //   // Tracing related threads:
  //   CHROME_THREAD_MEMORY_INFRA = 50;
  //   CHROME_THREAD_SAMPLING_PROFILER = 51;
  // };
  // optional ChromeThreadType chrome_thread_type = 4;
  // // To support old UI. New UI should determine default sorting by thread_type.
  // optional int32 legacy_sort_index = 3;
  // // Deprecated. Use ClockSnapshot in combination with TracePacket's timestamp
  // // and timestamp_clock_id fields instead.
  // optional int64 reference_timestamp_us = 6;
  // // Absolute reference values. Clock values in subsequent TrackEvents can be
  // // encoded accumulatively and relative to these. This reduces their var-int
  // // encoding size.
  // // TODO(eseckler): Deprecated. Replace these with ClockSnapshot encoding.
  // optional int64 reference_thread_time_us = 7;
  // optional int64 reference_thread_instruction_count = 8;
}

// End of protos/perfetto/trace/track_event/thread_descriptor.proto

// Begin of protos/perfetto/trace/track_event/process_descriptor.proto

// Describes a process's attributes. Emitted as part of a TrackDescriptor,
// usually by the process's main thread.
//
// Next id: 9.
message ProcessDescriptor {
  optional int32 pid = 1;
  repeated string cmdline = 2;
  optional string process_name = 6;

  optional int32 process_priority = 5;
  // Process start time in nanoseconds.
  // The timestamp refers to the trace clock by default. Other clock IDs
  // provided in TracePacket are not supported.
  optional int64 start_timestamp_ns = 7;

  // // ---------------------------------------------------------------------------
  // // Deprecated / legacy fields, which will be removed in the future:
  // // ---------------------------------------------------------------------------
  //
  // // See chromium's content::ProcessType.
  // enum ChromeProcessType {
  //   PROCESS_UNSPECIFIED = 0;
  //   PROCESS_BROWSER = 1;
  //   PROCESS_RENDERER = 2;
  //   PROCESS_UTILITY = 3;
  //   PROCESS_ZYGOTE = 4;
  //   PROCESS_SANDBOX_HELPER = 5;
  //   PROCESS_GPU = 6;
  //   PROCESS_PPAPI_PLUGIN = 7;
  //   PROCESS_PPAPI_BROKER = 8;
  // }
  // optional ChromeProcessType chrome_process_type = 4;
  //
  // // To support old UI. New UI should determine default sorting by process_type.
  // optional int32 legacy_sort_index = 3;
  //
  // // Labels can be used to further describe properties of the work performed by
  // // the process. For example, these can be used by Chrome renderer process to
  // // provide titles of frames being rendered.
  // repeated string process_labels = 8;
}

// End of protos/perfetto/trace/track_event/process_descriptor.proto

// Begin of protos/perfetto/trace/track_event/debug_annotation.proto

// Proto representation of untyped key/value annotations provided in TRACE_EVENT
// macros. Users of the Perfetto SDK should prefer to use the
// perfetto::TracedValue API to fill these protos, rather than filling them
// manually.
//
// Debug annotations are intended for debug use and are not considered a stable
// API of the trace contents. Trace-based metrics that use debug annotation
// values are prone to breakage, so please rely on typed TrackEvent fields for
// these instead.
//
// DebugAnnotations support nested arrays and dictionaries. Each entry is
// encoded as a single DebugAnnotation message. Only dictionary entries
// set the "name" field. The TrackEvent message forms an implicit root
// dictionary.
//
// Example TrackEvent with nested annotations:
//   track_event {
//     debug_annotations {
//       name: "foo"
//       dict_entries {
//         name: "a"
//         bool_value: true
//       }
//       dict_entries {
//         name: "b"
//         int_value: 123
//       }
//     }
//     debug_annotations {
//       name: "bar"
//       array_values {
//         string_value: "hello"
//       }
//       array_values {
//         string_value: "world"
//       }
//     }
//   }
//
// Next ID: 18.
// Reserved ID: 15
message DebugAnnotation {
  // Name fields are set only for dictionary entries.
  oneof name_field {
    // // interned DebugAnnotationName.
    // uint64 name_iid = 1;
    // non-interned variant.
    string name = 10;
  }

  oneof value {
    bool bool_value = 2;
    uint64 uint_value = 3;
    int64 int_value = 4;
    double double_value = 5;
    // Pointers are stored in a separate type as the JSON output treats them
    // differently from other uint64 values.
    uint64 pointer_value = 7;

    // // Deprecated. Use dict_entries / array_values instead.
    // NestedValue nested_value = 8;
    //
    // // Legacy instrumentation may not support conversion of nested data to
    // // NestedValue yet.
    // string legacy_json_value = 9;

    // interned and non-interned variants of strings.
    string string_value = 6;
    // // Corresponds to |debug_annotation_string_values| field in InternedData.
    // uint64 string_value_iid = 17;
  }

  // // Used to embed arbitrary proto messages (which are also typically used to
  // // represent typed TrackEvent arguments). |proto_type_name| or
  // // |proto_type_name_iid| are storing the full name of the proto messages (e.g.
  // // .perfetto.protos.DebugAnnotation) and |proto_value| contains the serialised
  // // proto messages. See |TracedValue::WriteProto| for more details.
  // oneof proto_type_descriptor {
  //   string proto_type_name = 16;
  //   // interned DebugAnnotationValueTypeName.
  //   uint64 proto_type_name_iid = 13;
  // }
  // optional bytes proto_value = 14;

  repeated DebugAnnotation dict_entries = 11;
  repeated DebugAnnotation array_values = 12;

  // // Deprecated legacy way to use nested values. Only kept for
  // // backwards-compatibility in TraceProcessor. May be removed in the future -
  // // code filling protos should use |dict_entries| and |array_values| instead.
  // message NestedValue {
  //   enum NestedType {
  //     // leaf value.
  //     UNSPECIFIED = 0;
  //     DICT = 1;
  //     ARRAY = 2;
  //   }
  //   optional NestedType nested_type = 1;
  //
  //   repeated string dict_keys = 2;
  //   repeated NestedValue dict_values = 3;
  //   repeated NestedValue array_values = 4;
  //   optional int64 int_value = 5;
  //   optional double double_value = 6;
  //   optional bool bool_value = 7;
  //   optional string string_value = 8;
  // }
}

// End of protos/perfetto/trace/track_event/debug_annotation.proto

// Begin of protos/perfetto/trace/track_event/track_descriptor.proto

// Defines a track for TrackEvents. Slices and instant events on the same track
// will be nested based on their timestamps, see TrackEvent::Type.
//
// A TrackDescriptor only needs to be emitted by one trace writer / producer and
// is valid for the entirety of the trace. To ensure the descriptor isn't lost
// when the ring buffer wraps, it should be reemitted whenever incremental state
// is cleared.
//
// As a fallback, TrackEvents emitted without an explicit track association will
// be associated with an implicit trace-global track (uuid = 0), see also
// |TrackEvent::track_uuid|. It is possible but not necessary to emit a
// TrackDescriptor for this implicit track.
//
// Next id: 11.
message TrackDescriptor {
  // Unique ID that identifies this track. This ID is global to the whole trace.
  // Producers should ensure that it is unlikely to clash with IDs emitted by
  // other producers. A value of 0 denotes the implicit trace-global track.
  //
  // For example, legacy TRACE_EVENT macros may use a hash involving the async
  // event id + id_scope, pid, and/or tid to compute this ID.
  optional uint64 uuid = 1;

  // A parent track reference can be used to describe relationships between
  // tracks. For example, to define an asynchronous track which is scoped to a
  // specific process, specify the uuid for that process's process track here.
  // Similarly, to associate a COUNTER_THREAD_TIME_NS counter track with a
  // thread, specify the uuid for that thread's thread track here.
  optional uint64 parent_uuid = 5;

  // Name of the track. Optional - if unspecified, it may be derived from the
  // process/thread name (process/thread tracks), the first event's name (async
  // tracks), or counter name (counter tracks).
  oneof static_or_dynamic_name {
    string name = 2;
    // // This field is only set by the SDK when perfetto::StaticString is
    // // provided.
    // string static_name = 10;
    // // Equivalent to name, used just to mark that the data is coming from
    // // android.os.Trace.
    // string atrace_name = 13;
  };

  // A human-readable description of the track providing more context about its
  // data. In the UI, this is shown in a popup when the track's help button is
  // clicked.
  optional string description = 14;

  // Associate the track with a process, making it the process-global track.
  // There should only be one such track per process (usually for instant
  // events; trace processor uses this fact to detect pid reuse). If you need
  // more (e.g. for asynchronous events), create child tracks using parent_uuid.
  //
  // Trace processor will merge events on a process track with slice-type events
  // from other sources (e.g. ftrace) for the same process into a single
  // timeline view.
  optional ProcessDescriptor process = 3;
  // optional ChromeProcessDescriptor chrome_process = 6;

  // Associate the track with a thread, indicating that the track's events
  // describe synchronous code execution on the thread. There should only be one
  // such track per thread (trace processor uses this fact to detect tid reuse).
  //
  // Trace processor will merge events on a thread track with slice-type events
  // from other sources (e.g. ftrace) for the same thread into a single timeline
  // view.
  optional ThreadDescriptor thread = 4;
  // optional ChromeThreadDescriptor chrome_thread = 7;

  // Descriptor for a counter track. If set, the track will only support
  // TYPE_COUNTER TrackEvents (and values provided via TrackEvent's
  // |extra_counter_values|).
  optional CounterDescriptor counter = 8;

  // // If true, forces Trace Processor to use separate tracks for track events
  // // and system events for the same thread.
  // //
  // // Track events timestamps in Chrome have microsecond resolution, while
  // // system events use nanoseconds. It results in broken event nesting when
  // // track events and system events share a track.
  // optional bool disallow_merging_with_system_tracks = 9;

  enum ChildTracksOrdering {
    UNKNOWN = 0;
    LEXICOGRAPHIC = 1;
    CHRONOLOGICAL = 2;
    EXPLICIT = 3;
  }
  optional ChildTracksOrdering child_ordering = 11;

  optional int32 sibling_order_rank = 12;

  enum SiblingMergeBehavior {
    SIBLING_MERGE_BEHAVIOR_UNSPECIFIED = 0;
    SIBLING_MERGE_BEHAVIOR_BY_TRACK_NAME = 1;
    SIBLING_MERGE_BEHAVIOR_NONE = 2;
    SIBLING_MERGE_BEHAVIOR_BY_SIBLING_MERGE_KEY = 3;
  }
  optional SiblingMergeBehavior sibling_merge_behavior = 15;

  optional string sibling_merge_key = 16;
}

// End of protos/perfetto/trace/track_event/track_descriptor.proto

// Begin of protos/perfetto/trace/track_event/track_event.proto

// NOTE: Full TrackEvent support in the client lib and chrome is WIP, thus these
// protos are still subject to change. Don't depend on them staying as they are.

// Trace events emitted by client instrumentation library (TRACE_EVENT macros),
// which describe activity on a track, such as a thread or asynchronous event
// track. The track is specified using separate TrackDescriptor messages and
// referred to via the track's UUID.
//
// A simple TrackEvent packet specifies a timestamp, category, name and type:
// ```protobuf
//   trace_packet {
//     timestamp: 1000
//     track_event {
//       categories: ["my_cat"]
//       name: "my_event"
//       type: TYPE_INSTANT
//      }
//    }
// ```
//
// To associate an event with a custom track (e.g. a thread), the track is
// defined in a separate packet and referred to from the TrackEvent by its UUID:
// ```protobuf
//   trace_packet {
//     track_descriptor {
//       track_uuid: 1234
//       name: "my_track"
//
//       // Optionally, associate the track with a thread.
//       thread_descriptor {
//         pid: 10
//         tid: 10
//         ..
//       }
//     }
//   }
// ```
//
// A pair of TYPE_SLICE_BEGIN and _END events form a slice on the track:
//
// ```protobuf
//   trace_packet {
//     timestamp: 1200
//     track_event {
//       track_uuid: 1234
//       categories: ["my_cat"]
//       name: "my_slice"
//       type: TYPE_SLICE_BEGIN
//     }
//   }
//   trace_packet {
//     timestamp: 1400
//     track_event {
//       track_uuid: 1234
//       type: TYPE_SLICE_END
//     }
//   }
// ```
// TrackEvents also support optimizations to reduce data repetition and encoded
// data size, e.g. through data interning (names, categories, ...) and delta
// encoding of timestamps/counters. For details, see the InternedData message.
// Further, default values for attributes of events on the same sequence (e.g.
// their default track association) can be emitted as part of a
// TrackEventDefaults message.
//
// Next reserved id: 13 (up to 15). Next id: 52.
message TrackEvent {
  // Names of categories of the event. In the client library, categories are a
  // way to turn groups of individual events on or off.
  repeated string categories = 22;

  // // interned EventCategoryName.
  // repeated uint64 category_iids = 3;

  // Optional name of the event for its display in trace viewer. May be left
  // unspecified for events with typed arguments.
  //
  // Note that metrics should not rely on event names, as they are prone to
  // changing. Instead, they should use typed arguments to identify the events
  // they are interested in.
  oneof name_field {
    // non-interned variant.
    string name = 23;
    // // interned EventName.
    // uint64 name_iid = 10;
  }

  // Type of the TrackEvent (required if |phase| in LegacyEvent is not set).
  enum Type {
    TYPE_UNSPECIFIED = 0;

    // Slice events are events that have a begin and end timestamp, i.e. a
    // duration. They can be nested similar to a callstack: If, on the same
    // track, event B begins after event A, but before A ends, B is a child
    // event of A and will be drawn as a nested event underneath A in the UI.
    // Note that child events should always end before their parents (e.g. B
    // before A).
    //
    // Each slice event is formed by a pair of BEGIN + END events. The END event
    // does not need to repeat any TrackEvent fields it has in common with its
    // corresponding BEGIN event. Arguments and debug annotations of the BEGIN +
    // END pair will be merged during trace import.
    //
    // Note that we deliberately chose not to support COMPLETE events (which
    // would specify a duration directly) since clients would need to delay
    // writing them until the slice is completed, which can result in reordered
    // events in the trace and loss of unfinished events at the end of a trace.
    TYPE_SLICE_BEGIN = 1;
    TYPE_SLICE_END = 2;

    // Instant events are nestable events without duration. They can be children
    // of slice events on the same track.
    TYPE_INSTANT = 3;

    // Event that provides a value for a counter track. |track_uuid| should
    // refer to a counter track and |counter_value| set to the new value. Note
    // that most other TrackEvent fields (e.g. categories, name, ..) are not
    // supported for TYPE_COUNTER events. See also CounterDescriptor.
    TYPE_COUNTER = 4;
  }
  optional Type type = 9;

  // Identifies the track of the event. The default value may be overridden
  // using TrackEventDefaults, e.g., to specify the track of the TraceWriter's
  // sequence (in most cases sequence = one thread). If no value is specified
  // here or in TrackEventDefaults, the TrackEvent will be associated with an
  // implicit trace-global track (uuid 0). See TrackDescriptor::uuid.
  optional uint64 track_uuid = 11;

  // A new value for a counter track. |track_uuid| should refer to a track with
  // a CounterDescriptor, and |type| should be TYPE_COUNTER. For a more
  // efficient encoding of counter values that are sampled at the beginning/end
  // of a slice, see |extra_counter_values| and |extra_counter_track_uuids|.
  // Counter values can optionally be encoded in as delta values (positive or
  // negative) on each packet sequence (see CounterIncrementalBase).
  oneof counter_value_field {
    int64 counter_value = 30;
    double double_counter_value = 44;
  }

  // // To encode counter values more efficiently, we support attaching additional
  // // counter values to a TrackEvent of any type. All values will share the same
  // // timestamp specified in the TracePacket. The value at
  // // extra_counter_values[N] is for the counter track referenced by
  // // extra_counter_track_uuids[N].
  // //
  // // |extra_counter_track_uuids| may also be set via TrackEventDefaults. There
  // // should always be equal or more uuids than values. It is valid to set more
  // // uuids (e.g. via defaults) than values. If uuids are specified in
  // // TrackEventDefaults and a TrackEvent, the TrackEvent uuids override the
  // // default uuid list.
  // //
  // // For example, this allows snapshotting the thread time clock at each
  // // thread-track BEGIN and END event to capture the cpu time delta of a slice.
  // repeated uint64 extra_counter_track_uuids = 31;
  // repeated int64 extra_counter_values = 12;
  //
  // // Counter snapshots using floating point instead of integer values.
  // repeated uint64 extra_double_counter_track_uuids = 45;
  // repeated double extra_double_counter_values = 46;

  // IDs of flows originating, passing through, or ending at this event.
  // Flow IDs are global within a trace.
  //
  // A flow connects a sequence of TrackEvents within or across tracks, e.g.
  // an input event may be handled on one thread but cause another event on
  // a different thread - a flow between the two events can associate them.
  //
  // The direction of the flows between events is inferred from the events'
  // timestamps. The earliest event with the same flow ID becomes the source
  // of the flow. Any events thereafter are intermediate steps of the flow,
  // until the flow terminates at the last event with the flow ID.
  //
  // Flows can also be explicitly terminated (see |terminating_flow_ids|), so
  // that the same ID can later be reused for another flow.
  // DEPRECATED. Only kept for backwards compatibility. Use |flow_ids|.
  repeated fixed64 flow_ids = 47;

  // // DEPRECATED. Only kept for backwards compatibility. Use |flow_ids|.
  // repeated uint64 flow_ids_old = 36 [ deprecated = true ];

  // List of flow ids which should terminate on this event
  //
  // Any one flow ID should be either listed as part of |flow_ids| OR
  // |terminating_flow_ids|, not both.
  repeated fixed64 terminating_flow_ids = 48;

  // // DEPRECATED. Only kept for backwards compatibility.  Use
  // // |terminating_flow_ids|.
  // repeated uint64 terminating_flow_ids_old = 42 [ deprecated = true ];
  
  // An opaque identifier to correlate this slice with other slices that are
  // considered part of the same logical operation, even if they are not
  // causally connected. Examples uses of a correlation id might be the number
  // of frame going through various stages of rendering in a GPU, the id for an
  // RPC request going through a distributed system, or the id of a network
  // request going through various stages of processing by the kernel.
  //
  // NOTE: if the events *are* causually connected, you probably want to use
  // flows instead of OR in addition to correlation ids.
  //
  // UIs can use this identifier to visually link these slices, for instance,
  // by assigning them a consistent color or highlighting the entire correlated
  // set when one slice is hovered.
  //
  // Only one field within this 'oneof' should be set to define the correlation.
  oneof correlation_id_field {
    // A 64-bit unsigned integer used as the correlation ID.
    //
    // Best for performance and compact traces if the identifier is naturally
    // numerical or can be easily mapped to one by the trace producer.
    uint64 correlation_id = 52;

    // A string value used as the correlation ID.
    //
    // Offers maximum flexibility for human-readable or complex identifiers
    // (e.g., GUIDs). Note: Using many unique, long strings may increase trace
    // size. For frequently repeated string identifiers, consider
    // 'correlation_id_string_iid'.
    string correlation_id_str = 53;

    // An interned string identifier (an IID) for correlation.
    //
    // This 64-bit ID refers to a string defined in the 'correlation_id_str'
    // field within the packet sequence's InternedData. This approach combines
    // the descriptiveness and uniqueness of strings with the efficiency of
    // integer IDs for storage and comparison, especially for identifiers that
    // repeat across many events.
    uint64 correlation_id_str_iid = 54;
  }

  // ---------------------------------------------------------------------------
  // TrackEvent arguments:
  // ---------------------------------------------------------------------------

  // Unstable key/value annotations shown in the trace viewer but not intended
  // for metrics use.
  repeated DebugAnnotation debug_annotations = 4;

  // // Typed event arguments:
  // optional TaskExecution task_execution = 5;
  // optional LogMessage log_message = 21;
  // optional ChromeCompositorSchedulerState cc_scheduler_state = 24;
  // optional ChromeUserEvent chrome_user_event = 25;
  // optional ChromeKeyedService chrome_keyed_service = 26;
  // optional ChromeLegacyIpc chrome_legacy_ipc = 27;
  // optional ChromeHistogramSample chrome_histogram_sample = 28;
  // optional ChromeLatencyInfo chrome_latency_info = 29;
  // // DEPRECATED. Only kept for backwards compatibility. Use the
  // // |ChromeTrackEvent.frame_reporter| extension in
  // // https://source.chromium.org/chromium/chromium/src/+/main:base/tracing/protos/chrome_track_event.proto
  // // instead.
  // optional ChromeFrameReporter chrome_frame_reporter = 32 [deprecated = true];
  // optional ChromeApplicationStateInfo chrome_application_state_info = 39;
  // optional ChromeRendererSchedulerState chrome_renderer_scheduler_state = 40;
  // optional ChromeWindowHandleEventInfo chrome_window_handle_event_info = 41;
  // optional ChromeContentSettingsEventInfo chrome_content_settings_event_info = 43;
  // optional ChromeActiveProcesses chrome_active_processes = 49;
  // optional Screenshot screenshot = 50;
  // // This field is used only if the source location represents the function that
  // // executes during this event.
  // oneof source_location_field {
  //   // Non-interned field.
  //   SourceLocation source_location = 33;
  //   // Interned field.
  //   uint64 source_location_iid = 34;
  // }
  //
  // optional ChromeMessagePump chrome_message_pump = 35;
  // optional ChromeMojoEventInfo chrome_mojo_event_info = 38;

  // https://source.chromium.org/chromium/chromium/src/+/main:base/tracing/protos/chrome_track_event.proto
  extensions 1000 to 1999;
  // Extension range reserved for https://b.corp.google.com/issues/301227627.
  extensions 2000 to 2000;
  // Extension range for future use.
  extensions 2001 to 9899;
  // Reserved for Perfetto unit and integration tests.
  extensions 9900 to 10000;

  // // ---------------------------------------------------------------------------
  // // Deprecated / legacy event fields, which will be removed in the future:
  // // ---------------------------------------------------------------------------
  //
  // // Deprecated. Use the |timestamp| and |timestamp_clock_id| fields in
  // // TracePacket instead.
  // //
  // // Timestamp in microseconds (usually CLOCK_MONOTONIC).
  // oneof timestamp {
  //   // Delta timestamp value since the last TrackEvent or ThreadDescriptor. To
  //   // calculate the absolute timestamp value, sum up all delta values of the
  //   // preceding TrackEvents since the last ThreadDescriptor and add the sum to
  //   // the |reference_timestamp| in ThreadDescriptor. This value should always
  //   // be positive.
  //   int64 timestamp_delta_us = 1;
  //   // Absolute value (e.g. a manually specified timestamp in the macro).
  //   // This is a one-off value that does not affect delta timestamp computation
  //   // in subsequent TrackEvents.
  //   int64 timestamp_absolute_us = 16;
  // }
  //
  // // Deprecated. Use |extra_counter_values| and |extra_counter_track_uuids| to
  // // encode thread time instead.
  // //
  // // CPU time for the current thread (e.g., CLOCK_THREAD_CPUTIME_ID) in
  // // microseconds.
  // oneof thread_time {
  //   // Delta timestamp value since the last TrackEvent or ThreadDescriptor. To
  //   // calculate the absolute timestamp value, sum up all delta values of the
  //   // preceding TrackEvents since the last ThreadDescriptor and add the sum to
  //   // the |reference_timestamp| in ThreadDescriptor. This value should always
  //   // be positive.
  //   int64 thread_time_delta_us = 2;
  //   // This is a one-off absolute value that does not affect delta timestamp
  //   // computation in subsequent TrackEvents.
  //   int64 thread_time_absolute_us = 17;
  // }
  //
  // // Deprecated. Use |extra_counter_values| and |extra_counter_track_uuids| to
  // // encode thread instruction count instead.
  // //
  // // Value of the instruction counter for the current thread.
  // oneof thread_instruction_count {
  //   // Same encoding as |thread_time| field above.
  //   int64 thread_instruction_count_delta = 8;
  //   int64 thread_instruction_count_absolute = 20;
  // }
  //
  // // Apart from {category, time, thread time, tid, pid}, other legacy trace
  // // event attributes are initially simply proxied for conversion to a JSON
  // // trace. We intend to gradually transition these attributes to similar native
  // // features in TrackEvent (e.g. async + flow events), or deprecate them
  // // without replacement where transition is unsuitable.
  // //
  // // Next reserved id: 16 (up to 16).
  // // Next id: 20.
  // message LegacyEvent {
  //   // Deprecated, use TrackEvent::name(_iid) instead.
  //   // interned EventName.
  //   optional uint64 name_iid = 1;
  //   optional int32 phase = 2;
  //   optional int64 duration_us = 3;
  //   optional int64 thread_duration_us = 4;
  //
  //   // Elapsed retired instruction count during the event.
  //   optional int64 thread_instruction_delta = 15;
  //
  //   // used to be |flags|.
  //   reserved 5;
  //
  //   oneof id {
  //     uint64 unscoped_id = 6;
  //     uint64 local_id = 10;
  //     uint64 global_id = 11;
  //   }
  //   // Additional optional scope for |id|.
  //   optional string id_scope = 7;
  //
  //   // Consider the thread timestamps for async BEGIN/END event pairs as valid.
  //   optional bool use_async_tts = 9;
  //
  //   // Idenfifies a flow. Flow events with the same bind_id are connected.
  //   optional uint64 bind_id = 8;
  //   // Use the enclosing slice as binding point for a flow end event instead of
  //   // the next slice. Flow start/step events always bind to the enclosing
  //   // slice.
  //   optional bool bind_to_enclosing = 12;
  //
  //   enum FlowDirection {
  //     FLOW_UNSPECIFIED = 0;
  //     FLOW_IN = 1;
  //     FLOW_OUT = 2;
  //     FLOW_INOUT = 3;
  //   }
  //   optional FlowDirection flow_direction = 13;
  //
  //   enum InstantEventScope {
  //     SCOPE_UNSPECIFIED = 0;
  //     SCOPE_GLOBAL = 1;
  //     SCOPE_PROCESS = 2;
  //     SCOPE_THREAD = 3;
  //   }
  //   optional InstantEventScope instant_event_scope = 14;
  //
  //   // Override the pid/tid if the writer needs to emit events on behalf of
  //   // another process/thread. This should be the exception. Normally, the
  //   // pid+tid from ThreadDescriptor is used.
  //   optional int32 pid_override = 18;
  //   optional int32 tid_override = 19;
  // }
  //
  // optional LegacyEvent legacy_event = 6;
}

// End of protos/perfetto/trace/track_event/track_event.proto

// Begin of protos/perfetto/trace/trace_packet.proto

// TracePacket is the root object of a Perfetto trace.
// A Perfetto trace is a linear sequence of TracePacket(s).
//
// The tracing service guarantees that all TracePacket(s) written by a given
// TraceWriter are seen in-order, without gaps or duplicates. If, for any
// reason, a TraceWriter sequence becomes invalid, no more packets are returned
// to the Consumer (or written into the trace file).
// TracePacket(s) written by different TraceWriter(s), hence even different
// data sources, can be seen in arbitrary order.
// The consumer can re-establish a total order, if interested, using the packet
// timestamps, after having synchronized the different clocks onto a global
// clock.
//
// The tracing service is agnostic of the content of TracePacket, with the
// exception of few fields (e.g.. trusted_*, trace_config) that are written by
// the service itself.
//
// See the [Buffers and Dataflow](/docs/concepts/buffers.md) doc for details.
//
// Next reserved id: 14 (up to 15).
// Next id: 113.
message TracePacket {
  // The timestamp of the TracePacket.
  // By default this timestamps refers to the trace clock (CLOCK_BOOTTIME on
  // Android). It can be overridden using a different timestamp_clock_id.
  // The clock domain definition in ClockSnapshot can also override:
  // - The unit (default: 1ns).
  // - The absolute vs delta encoding (default: absolute timestamp).
  optional uint64 timestamp = 8;

  // // Specifies the ID of the clock used for the TracePacket |timestamp|. Can be
  // // one of the built-in types from ClockSnapshot::BuiltinClocks, or a
  // // producer-defined clock id.
  // // If unspecified and if no default per-sequence value has been provided via
  // // TracePacketDefaults, it defaults to BuiltinClocks::BOOTTIME.
  // optional uint32 timestamp_clock_id = 58;

  oneof data {
    // // Events from the Linux kernel ftrace infrastructure.
    // FtraceEventBundle ftrace_events = 1;
    // ProcessTree process_tree = 2;
    // ProcessStats process_stats = 9;
    // InodeFileMap inode_file_map = 4;
    // ChromeEventBundle chrome_events = 5;
    // ClockSnapshot clock_snapshot = 6;
    // SysStats sys_stats = 7;
    TrackEvent track_event = 11;
    // TraceUuid trace_uuid = 89;
    // TraceConfig trace_config = 33;
    // FtraceStats ftrace_stats = 34;
    // TraceStats trace_stats = 35;
    // ProfilePacket profile_packet = 37;
    // StreamingAllocation streaming_allocation = 74;
    // StreamingFree streaming_free = 75;
    // BatteryCounters battery = 38;
    // PowerRails power_rails = 40;
    // AndroidLogPacket android_log = 39;
    // SystemInfo system_info = 45;
    // Trigger trigger = 46;
    // ChromeTrigger chrome_trigger = 109;
    // PackagesList packages_list = 47;
    // ChromeBenchmarkMetadata chrome_benchmark_metadata = 48;
    // PerfettoMetatrace perfetto_metatrace = 49;
    // ChromeMetadataPacket chrome_metadata = 51;
    // GpuCounterEvent gpu_counter_event = 52;
    // GpuRenderStageEvent gpu_render_stage_event = 53;
    // StreamingProfilePacket streaming_profile_packet = 54;
    // HeapGraph heap_graph = 56;
    // GraphicsFrameEvent graphics_frame_event = 57;
    // VulkanMemoryEvent vulkan_memory_event = 62;
    // GpuLog gpu_log = 63;
    // VulkanApiEvent vulkan_api_event = 65;
    // PerfSample perf_sample = 66;
    // CpuInfo cpu_info = 67;
    // SmapsPacket smaps_packet = 68;
    // TracingServiceEvent service_event = 69;
    // InitialDisplayState initial_display_state = 70;
    // GpuMemTotalEvent gpu_mem_total_event = 71;
    // MemoryTrackerSnapshot memory_tracker_snapshot = 73;
    // FrameTimelineEvent frame_timeline_event = 76;
    // AndroidEnergyEstimationBreakdown android_energy_estimation_breakdown = 77;
    // UiState ui_state = 78;
    // AndroidCameraFrameEvent android_camera_frame_event = 80;
    // AndroidCameraSessionStats android_camera_session_stats = 81;
    // TranslationTable translation_table = 82;
    // AndroidGameInterventionList android_game_intervention_list = 83;
    // StatsdAtom statsd_atom = 84;
    // AndroidSystemProperty android_system_property = 86;
    // EntityStateResidency entity_state_residency = 91;
    // // Only used in profile packets.
    // ModuleSymbols module_symbols = 61;
    // DeobfuscationMapping deobfuscation_mapping = 64;
    // // Only used by TrackEvent.
    TrackDescriptor track_descriptor = 60;
    // // Deprecated, use TrackDescriptor instead.
    // ProcessDescriptor process_descriptor = 43;
    // // Deprecated, use TrackDescriptor instead.
    // ThreadDescriptor thread_descriptor = 44;
    // // This field is emitted at periodic intervals (~10s) and
    // // contains always the binary representation of the UUID
    // // {82477a76-b28d-42ba-81dc-33326d57a079}. This is used to be able to
    // // efficiently partition long traces without having to fully parse them.
    // bytes synchronization_marker = 36;
    // // Zero or more proto encoded trace packets compressed using deflate.
    // // Each compressed_packets TracePacket (including the two field ids and
    // // sizes) should be less than 512KB.
    // bytes compressed_packets = 50;
    // // Data sources can extend the trace proto with custom extension protos (see
    // // docs/design-docs/extensions.md). When they do that, the descriptor of
    // // their extension proto descriptor is serialized in this packet. This
    // // allows trace_processor to deserialize extended messages using reflection
    // // even if the extension proto is not checked in the Perfetto repo.
    // ExtensionDescriptor extension_descriptor = 72;
    // // Represents a single packet sent or received by the network.
    // NetworkPacketEvent network_packet = 88;
    // // Represents one or more packets sent or received by the network.
    // NetworkPacketBundle network_packet_bundle = 92;
    // // The "range of interest" for track events. See the message definition
    // // comments for more details.
    // TrackEventRangeOfInterest track_event_range_of_interest = 90;
    // // Winscope traces
    // LayersSnapshotProto surfaceflinger_layers_snapshot = 93;
    // TransactionTraceEntry surfaceflinger_transactions = 94;
    // ShellTransition shell_transition = 96;
    // ShellHandlerMappings shell_handler_mappings = 97;
    // ProtoLogMessage protolog_message = 104;
    // ProtoLogViewerConfig protolog_viewer_config = 105;
    // WinscopeExtensions winscope_extensions = 112;
    // // Events from the Windows etw infrastructure.
    // EtwTraceEventBundle etw_events = 95;
    // V8JsCode v8_js_code = 99;
    // V8InternalCode v8_internal_code = 100;
    // V8WasmCode v8_wasm_code = 101;
    // V8RegExpCode v8_reg_exp_code = 102;
    // V8CodeMove v8_code_move = 103;
    // // Clock synchronization with remote machines.
    // RemoteClockSync remote_clock_sync = 107;
    // PixelModemEvents pixel_modem_events = 110;
    // PixelModemTokenDatabase pixel_modem_token_database = 111;
    // // This field is only used for testing.
    // TestEvent for_testing = 900;
    // Trigger clone_snapshot_trigger = 113;
    // BluetoothTraceEvent bluetooth_trace_event = 114;
    // KernelWakelockData kernel_wakelock_data = 115;
    // AppWakelockBundle app_wakelock_bundle = 116;
    // // Generic events for a standard kernel implementation
    // GenericKernelTaskStateEvent generic_kernel_task_state_event = 117;
    // GenericKernelCpuFrequencyEvent generic_kernel_cpu_freq_event = 118;
    // CpuPerUidData cpu_per_uid_data = 119;
    // GenericKernelTaskRenameEvent generic_kernel_task_rename_event = 120;
    // EvdevEvent evdev_event = 121;
  }

  // // AndroidInputEvent android_input_event (moved to winscope_extensions)
  // reserved 106;

  // Trusted user id of the producer which generated this packet. Keep in sync
  // with TrustedPacket.trusted_uid.
  //
  // TODO(eseckler): Emit this field in a PacketSequenceDescriptor message
  // instead.
  oneof optional_trusted_uid { int32 trusted_uid = 3; };

  // Service-assigned identifier of the packet sequence this packet belongs to.
  // Uniquely identifies a producer + writer pair within the tracing session. A
  // value of zero denotes an invalid ID. Keep in sync with
  // TrustedPacket.trusted_packet_sequence_id.
  oneof optional_trusted_packet_sequence_id {
    uint32 trusted_packet_sequence_id = 10;
  }

  // Trusted process id of the producer which generated this packet, written by
  // the service.
  optional int32 trusted_pid = 79;

  // // Incrementally emitted interned data, valid only on the packet's sequence
  // // (packets with the same |trusted_packet_sequence_id|). The writer will
  // // usually emit new interned data in the same TracePacket that first refers to
  // // it (since the last reset of interning state). It may also be emitted
  // // proactively in advance of referring to them in later packets.
  // optional InternedData interned_data = 12;
  // // enum SequenceFlags {
  // //   SEQ_UNSPECIFIED = 0;
  // //
  // //   // Set by the writer to indicate that it will re-emit any incremental data
  // //   // for the packet's sequence before referring to it again. This includes
  // //   // interned data as well as periodically emitted data like
  // //   // Process/ThreadDescriptors. This flag only affects the current packet
  // //   // sequence (see |trusted_packet_sequence_id|).
  // //   //
  // //   // When set, this TracePacket and subsequent TracePackets on the same
  // //   // sequence will not refer to any incremental data emitted before this
  // //   // TracePacket. For example, previously emitted interned data will be
  // //   // re-emitted if it is referred to again.
  // //   //
  // //   // When the reader detects packet loss (|previous_packet_dropped|), it needs
  // //   // to skip packets in the sequence until the next one with this flag set, to
  // //   // ensure intact incremental data.
  // //   SEQ_INCREMENTAL_STATE_CLEARED = 1;
  // //
  // //   // This packet requires incremental state, such as TracePacketDefaults or
  // //   // InternedData, to be parsed correctly. The trace reader should skip this
  // //   // packet if incremental state is not valid on this sequence, i.e. if no
  // //   // packet with the SEQ_INCREMENTAL_STATE_CLEARED flag has been seen on the
  // //   // current |trusted_packet_sequence_id|.
  // //   SEQ_NEEDS_INCREMENTAL_STATE = 2;
  // // };
  // // optional uint32 sequence_flags = 13;
  // // DEPRECATED. Moved to SequenceFlags::SEQ_INCREMENTAL_STATE_CLEARED.
  // optional bool incremental_state_cleared = 41;
  // // Default values for fields of later TracePackets emitted on this packet's
  // // sequence (TracePackets with the same |trusted_packet_sequence_id|).
  // // It must be reemitted when incremental state is cleared (see
  // // |incremental_state_cleared|).
  // // Requires that any future packet emitted on the same sequence specifies
  // // the SEQ_NEEDS_INCREMENTAL_STATE flag.
  // // TracePacketDefaults always override the global defaults for any future
  // // packet on this sequence (regardless of SEQ_NEEDS_INCREMENTAL_STATE).
  // optional TracePacketDefaults trace_packet_defaults = 59;
  // // Flag set by the service if, for the current packet sequence (see
  // // |trusted_packet_sequence_id|), either:
  // // * this is the first packet, or
  // // * one or multiple packets were dropped since the last packet that the
  // //   consumer read from the sequence. This can happen if chunks in the trace
  // //   buffer are overridden before the consumer could read them when the trace
  // //   is configured in ring buffer mode.
  // //
  // // When packet loss occurs, incrementally emitted data (including interned
  // // data) on the sequence should be considered invalid up until the next packet
  // // with SEQ_INCREMENTAL_STATE_CLEARED set.
  // optional bool previous_packet_dropped = 42;
  // // Flag set by a producer (starting from SDK v29) if, for the current packet
  // // sequence (see |trusted_packet_sequence_id|), this is the first packet.
  // //
  // // This flag can be used for distinguishing the two situations when
  // // processing the trace:
  // // 1. There are no prior events for the sequence because of data loss, e.g.
  // //    due to ring buffer wrapping.
  // // 2. There are no prior events for the sequence because it didn't start
  // //    before this packet (= there's definitely no preceding data loss).
  // //
  // // Given that older SDK versions do not support this flag, this flag not
  // // being present for a particular sequence does not necessarily imply data
  // // loss.
  // optional bool first_packet_on_sequence = 87;
  // // The machine ID for identifying trace packets in a multi-machine tracing
  // // session. Is emitted by the tracing service for producers running on a
  // // remote host (e.g. a VM guest). For more context: go/crosetto-vm-tracing.
  // optional uint32 machine_id = 98;
}

// End of protos/perfetto/trace/trace_packet.proto

// Begin of protos/perfetto/trace/trace.proto

message Trace {
  repeated TracePacket packet = 1;

  // Do NOT add any other field here. This is just a convenience wrapper for
  // the use case of a trace being saved to a file. There are other cases
  // (streaming) where TracePacket are directly streamed without being wrapped
  // in a Trace proto. Nothing should ever rely on the full trace, all the
  // logic should be based on TracePacket(s).
}

// End of protos/perfetto/trace/trace.proto

